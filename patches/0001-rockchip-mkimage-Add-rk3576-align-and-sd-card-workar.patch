From 864946e7b3c52d4d3dfbf5f82e5f7b5df1b99194 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Tue, 28 Jan 2025 01:30:12 +0000
Subject: [PATCH 1/7] rockchip: mkimage: Add rk3576 align and sd-card
 workaround

The BootROM on RK3576 has an issue loading boot images from an SD-card.
This issue can be worked around by injecting an initial boot image
before TPL that:

  writel(0x3ffff800, 0x3ff803b0)

Prepend an image containing binary code that does this and return to
BootROM to load next image, TPL.

TODO: embed the binary code into rkcommon.c

Signed-off-by: Jonas Karlman <jonas@kwiboo.se>
---
 rk3576-boost.bin | Bin 0 -> 24 bytes
 rk3576-boost.c   |  49 ++++++++
 tools/rkcommon.c | 286 ++++++++++++++++++++++++++++++-----------------
 3 files changed, 232 insertions(+), 103 deletions(-)
 create mode 100644 rk3576-boost.bin
 create mode 100644 rk3576-boost.c

diff --git a/rk3576-boost.bin b/rk3576-boost.bin
new file mode 100644
index 0000000000000000000000000000000000000000..de1618b1a162e5e5cfbbb35ef10fcbe76e07b257
GIT binary patch
literal 24
gcmZQ5Yq<2#Thxf*|ME|a3=BIN7#e~OFvnj50CxTfSO5S3

literal 0
HcmV?d00001

diff --git a/rk3576-boost.c b/rk3576-boost.c
new file mode 100644
index 00000000000..73ba22f8aa5
--- /dev/null
+++ b/rk3576-boost.c
@@ -0,0 +1,49 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+// Copyright Contributors to the U-Boot project.
+
+/*
+ * Generate assembly code for the c code in this file:
+ *  aarch64-linux-gnu-gcc -nostdlib -ffreestanding -Os -S -o rk3576-boost.S rk3576-boost.c
+ *
+ * Compile assembly code and extract the AArch64 binary code:
+ *  aarch64-linux-gnu-as -o rk3576-boost.o rk3576-boost.S
+ *  aarch64-linux-gnu-objcopy -O binary -j .text rk3576-boost.o rk3576-boost.bin
+ */
+
+#include <stdint.h>
+
+#define SYS_SRAM_BASE	0x3ff80000
+#define OFFSET		0x03b0
+
+int _start(void)
+{
+	uint32_t *sram = (void*)(SYS_SRAM_BASE + OFFSET);
+
+	/* set unknown value in sram to fix boot from sdmmc */
+	*(sram) = 0x3ffff800;
+
+	return 0;
+}
+
+/*
+	.arch armv8-a
+	.file	"rk3576-boost.c"
+	.text
+	.align	2
+	.global	_start
+	.type	_start, %function
+_start:
+.LFB0:
+	.cfi_startproc
+	mov	x0, 944
+	mov	w1, 1073739776
+	movk	x0, 0x3ff8, lsl 16
+	str	w1, [x0]
+	mov	w0, 0
+	ret
+	.cfi_endproc
+.LFE0:
+	.size	_start, .-_start
+	.ident	"GCC: (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0"
+	.section	.note.GNU-stack,"",@progbits
+*/
diff --git a/tools/rkcommon.c b/tools/rkcommon.c
index e7e78ef7e5b..81a5e8134a7 100644
--- a/tools/rkcommon.c
+++ b/tools/rkcommon.c
@@ -34,15 +34,16 @@ enum hash_type {
 /**
  * struct image_entry
  *
- * @size_and_off:	[31:16]image size;[15:0]image offset
- * @address:	default as 0xFFFFFFFF
+ * @offset:	image offset (unit as 512 byte blocks)
+ * @size:	image size (unit as 512 byte blocks)
+ * @address:	load address (default as 0xFFFFFFFF)
  * @flag:	no use
  * @counter:	no use
  * @hash:	hash of image
- *
  */
 struct image_entry {
-	uint32_t size_and_off;
+	uint16_t offset;
+	uint16_t size;
 	uint32_t address;
 	uint32_t flag;
 	uint32_t counter;
@@ -56,18 +57,23 @@ struct image_entry {
  * This is stored at SD card block 64 (where each block is 512 bytes)
  *
  * @magic:	Magic (must be RK_MAGIC_V2)
- * @size_and_nimage:	[31:16]number of images;[15:0]
- *			offset to hash field of header(unit as 4Byte)
- * @boot_flag:	[3:0]hash type(0:none,1:sha256,2:sha512)
- * @signature:	hash or signature for header info
+ * @size:	offset to hash field of header (unit as 4 bytes)
+ * @num_images:	number of images
+ * @boot_flag:	[3:0] hash type (0:none, 1:sha256, 2:sha512)
+ * @images:	images
+ * @hash:	hash or signature for header info
  *
+ * Other fields are not used by U-Boot
  */
 struct header0_info_v2 {
 	uint32_t magic;
 	uint8_t reserved[4];
-	uint32_t size_and_nimage;
+	uint16_t size;
+	uint16_t num_images;
 	uint32_t boot_flag;
-	uint8_t reserved1[104];
+	uint8_t reserved1[32];
+	uint32_t boot0_param[10];
+	uint32_t boot1_param[8];
 	struct image_entry images[4];
 	uint8_t reserved2[1064];
 	uint8_t hash[512];
@@ -134,6 +140,7 @@ struct spl_info {
 	const uint32_t spl_size;
 	const bool spl_rc4;
 	const uint32_t header_ver;
+	const uint32_t align;
 };
 
 static struct spl_info spl_infos[] = {
@@ -152,24 +159,26 @@ static struct spl_info spl_infos[] = {
 	{ "rv1126", "110B", 0x10000 - 0x1000, false, RK_HEADER_V1 },
 	{ "rk3528", "RK35", 0x10000 - 0x1000, false, RK_HEADER_V2 },
 	{ "rk3568", "RK35", 0x10000 - 0x1000, false, RK_HEADER_V2 },
-	{ "rk3576", "RK35", 0x80000 - 0x1000, false, RK_HEADER_V2 },
+	{ "rk3576", "RK35", 0x80000 - 0x1000, false, RK_HEADER_V2, 8 },
 	{ "rk3588", "RK35", 0x100000 - 0x1000, false, RK_HEADER_V2 },
 };
 
 /**
  * struct spl_params - spl params parsed in check_params()
  *
- * @init_file:		Init data file path
- * @init_size:		Aligned size of init data in bytes
- * @boot_file:		Boot data file path
- * @boot_size:		Aligned size of boot data in bytes
+ * @file:	image file path
+ * @size:	aligned size of image in bytes
+ * @address:	image load address
+ * @flag:	no use
  */
 
 struct spl_params {
-	char *init_file;
-	uint32_t init_size;
-	char *boot_file;
-	uint32_t boot_size;
+	struct {
+		char *file;
+		uint32_t size;
+		uint32_t address;
+		uint32_t flag;
+	} images[4];
 };
 
 static struct spl_params spl_params = { 0 };
@@ -193,14 +202,19 @@ static struct spl_info *rkcommon_get_spl_info(char *imagename)
 	return NULL;
 }
 
-static int rkcommon_get_aligned_size(struct image_tool_params *params,
-				     const char *fname)
+static bool rkcommon_is_header_v2(struct image_tool_params *params)
 {
-	int size;
+	struct spl_info *info = rkcommon_get_spl_info(params->imagename);
 
-	size = imagetool_get_filesize(params, fname);
-	if (size < 0)
-		return -1;
+	return (info->header_ver == RK_HEADER_V2);
+}
+
+static int rkcommon_get_aligned_size(struct image_tool_params *params, int size)
+{
+	struct spl_info *info = rkcommon_get_spl_info(params->imagename);
+
+	if (info->align)
+		return ROUND(size, info->align * RK_BLK_SIZE);
 
 	/*
 	 * Pad to a 2KB alignment, as required for init/boot size by the ROM
@@ -209,6 +223,27 @@ static int rkcommon_get_aligned_size(struct image_tool_params *params,
 	return ROUND(size, RK_SIZE_ALIGN);
 }
 
+static int rkcommon_get_header_size(struct image_tool_params *params)
+{
+	int header_size = rkcommon_is_header_v2(params) ?
+			  sizeof(struct header0_info_v2) :
+			  sizeof(struct header0_info);
+
+	return rkcommon_get_aligned_size(params, header_size);
+}
+
+static int rkcommon_get_aligned_filesize(struct image_tool_params *params,
+					 const char *fname)
+{
+	int size;
+
+	size = imagetool_get_filesize(params, fname);
+	if (size < 0)
+		return -1;
+
+	return rkcommon_get_aligned_size(params, size);
+}
+
 int rkcommon_check_params(struct image_tool_params *params)
 {
 	int i, size;
@@ -223,34 +258,51 @@ int rkcommon_check_params(struct image_tool_params *params)
 	if (!rkcommon_get_spl_info(params->imagename))
 		goto err_spl_info;
 
-	spl_params.init_file = params->datafile;
+	spl_params.images[0].file = params->datafile;
+	for (i = 1; i < ARRAY_SIZE(spl_params.images); i++) {
+		spl_params.images[i].file =
+				strchr(spl_params.images[i - 1].file, ':');
+		if (!spl_params.images[i].file)
+			break;
 
-	spl_params.boot_file = strchr(spl_params.init_file, ':');
-	if (spl_params.boot_file) {
-		*spl_params.boot_file = '\0';
-		spl_params.boot_file += 1;
+		*spl_params.images[i].file = '\0';
+		spl_params.images[i].file += 1;
 	}
 
-	size = rkcommon_get_aligned_size(params, spl_params.init_file);
-	if (size < 0)
-		return EXIT_FAILURE;
-	spl_params.init_size = size;
+	for (i = 0; i < ARRAY_SIZE(spl_params.images); i++) {
+		if (!spl_params.images[i].file)
+			break;
 
-	/* Boot file is optional, and only for back-to-bootrom functionality. */
-	if (spl_params.boot_file) {
-		size = rkcommon_get_aligned_size(params, spl_params.boot_file);
+		size = rkcommon_get_aligned_filesize(params,
+						     spl_params.images[i].file);
 		if (size < 0)
 			return EXIT_FAILURE;
-		spl_params.boot_size = size;
+		spl_params.images[i].size = size;
 	}
 
-	if (spl_params.init_size > rkcommon_get_spl_size(params)) {
+	if (spl_params.images[0].size > rkcommon_get_spl_size(params)) {
 		fprintf(stderr,
 			"Error: SPL image is too large (size %#x than %#x)\n",
-			spl_params.init_size, rkcommon_get_spl_size(params));
+			spl_params.images[0].size, rkcommon_get_spl_size(params));
 		return EXIT_FAILURE;
 	}
 
+	if (!strcmp(params->imagename, "rk3576")) {
+		size = rkcommon_get_aligned_filesize(params, "rk3576-boost.bin");
+		if (size < 0)
+			return EXIT_SUCCESS;
+
+		for (i = ARRAY_SIZE(spl_params.images) - 1; i > 0; i--) {
+			spl_params.images[i] = spl_params.images[i - 1];
+		}
+
+		spl_params.images[0].file = "rk3576-boost.bin";
+		spl_params.images[0].size = size;
+
+		spl_params.images[0].address = 0x3ffc0000;
+		spl_params.images[1].address = 0x3ff81000;
+	}
+
 	return EXIT_SUCCESS;
 
 err_spl_info:
@@ -295,13 +347,6 @@ bool rkcommon_need_rc4_spl(struct image_tool_params *params)
 	return info->spl_rc4;
 }
 
-static bool rkcommon_is_header_v2(struct image_tool_params *params)
-{
-	struct spl_info *info = rkcommon_get_spl_info(params->imagename);
-
-	return (info->header_ver == RK_HEADER_V2);
-}
-
 static void do_sha256_hash(uint8_t *buf, uint32_t size, uint8_t *out)
 {
 	sha256_context ctx;
@@ -314,13 +359,14 @@ static void do_sha256_hash(uint8_t *buf, uint32_t size, uint8_t *out)
 static void rkcommon_set_header0(void *buf, struct image_tool_params *params)
 {
 	struct header0_info *hdr = buf;
-	uint32_t init_boot_size;
+	uint32_t init_boot_size, init_offset;
 
-	memset(buf, '\0', RK_INIT_OFFSET * RK_BLK_SIZE);
+	init_offset = rkcommon_get_header_size(params) / RK_BLK_SIZE;
+	memset(buf, '\0', init_offset * RK_BLK_SIZE);
 	hdr->magic = cpu_to_le32(RK_MAGIC);
 	hdr->disable_rc4 = cpu_to_le32(!rkcommon_need_rc4_spl(params));
-	hdr->init_offset = cpu_to_le16(RK_INIT_OFFSET);
-	hdr->init_size   = cpu_to_le16(spl_params.init_size / RK_BLK_SIZE);
+	hdr->init_offset = cpu_to_le16(init_offset);
+	hdr->init_size = cpu_to_le16(spl_params.images[0].size / RK_BLK_SIZE);
 
 	/*
 	 * init_boot_size needs to be set, as it is read by the BootROM
@@ -330,10 +376,11 @@ static void rkcommon_set_header0(void *buf, struct image_tool_params *params)
 	 * see https://lists.denx.de/pipermail/u-boot/2017-May/293267.html
 	 * for a more detailed explanation by Andy Yan
 	 */
-	if (spl_params.boot_file)
-		init_boot_size = spl_params.init_size + spl_params.boot_size;
+	if (spl_params.images[1].file)
+		init_boot_size = spl_params.images[0].size +
+				 spl_params.images[1].size;
 	else
-		init_boot_size = spl_params.init_size + RK_MAX_BOOT_SIZE;
+		init_boot_size = spl_params.images[0].size + RK_MAX_BOOT_SIZE;
 	hdr->init_boot_size = cpu_to_le16(init_boot_size / RK_BLK_SIZE);
 
 	rc4_encode(buf, RK_BLK_SIZE, rc4_key);
@@ -343,43 +390,43 @@ static void rkcommon_set_header0_v2(void *buf, struct image_tool_params *params)
 {
 	struct header0_info_v2 *hdr = buf;
 	uint32_t sector_offset, image_sector_count;
-	uint32_t image_size_array[2];
 	uint8_t *image_ptr = NULL;
 	int i;
 
-	printf("Image Type:   Rockchip %s boot image\n",
-		rkcommon_get_spl_hdr(params));
-	memset(buf, '\0', RK_INIT_OFFSET * RK_BLK_SIZE);
-	hdr->magic   = cpu_to_le32(RK_MAGIC_V2);
-	hdr->size_and_nimage = cpu_to_le32((2 << 16) + 384);
+	sector_offset = rkcommon_get_header_size(params) / RK_BLK_SIZE;
+	memset(buf, '\0', sector_offset * RK_BLK_SIZE);
+	hdr->magic = cpu_to_le32(RK_MAGIC_V2);
 	hdr->boot_flag = cpu_to_le32(HASH_SHA256);
-	sector_offset = 4;
-	image_size_array[0] = spl_params.init_size;
-	image_size_array[1] = spl_params.boot_size;
-
-	for (i = 0; i < 2; i++) {
-		image_sector_count = image_size_array[i] / RK_BLK_SIZE;
-		hdr->images[i].size_and_off = cpu_to_le32((image_sector_count
-							<< 16) + sector_offset);
-		hdr->images[i].address = 0xFFFFFFFF;
+
+	for (i = 0; i < ARRAY_SIZE(spl_params.images); i++) {
+		if (!spl_params.images[i].size)
+			break;
+		image_sector_count = spl_params.images[i].size / RK_BLK_SIZE;
+		hdr->images[i].offset = cpu_to_le16(sector_offset);
+		hdr->images[i].size = cpu_to_le16(image_sector_count);
+		hdr->images[i].address = spl_params.images[i].address ?: 0xFFFFFFFF;
+		hdr->images[i].flag = spl_params.images[i].flag;
 		hdr->images[i].counter = cpu_to_le32(i + 1);
 		image_ptr = buf + sector_offset * RK_BLK_SIZE;
-		do_sha256_hash(image_ptr, image_size_array[i],
+		do_sha256_hash(image_ptr, spl_params.images[i].size,
 			       hdr->images[i].hash);
 		sector_offset = sector_offset + image_sector_count;
 	}
 
+	hdr->num_images = cpu_to_le16(i);
+	hdr->size = cpu_to_le16(offsetof(typeof(*hdr), hash) / sizeof(uint32_t));
 	do_sha256_hash(buf, (void *)hdr->hash - buf, hdr->hash);
 }
 
 void rkcommon_set_header(void *buf,  struct stat *sbuf,  int ifd,
 			 struct image_tool_params *params)
 {
-	struct header1_info *hdr = buf + RK_SPL_HDR_START;
-
 	if (rkcommon_is_header_v2(params)) {
 		rkcommon_set_header0_v2(buf, params);
 	} else {
+		int header_size = rkcommon_get_header_size(params);
+		struct header1_info *hdr = buf + header_size;
+
 		rkcommon_set_header0(buf, params);
 
 		/* Set up the SPL name (i.e. copy spl_hdr over) */
@@ -387,14 +434,14 @@ void rkcommon_set_header(void *buf,  struct stat *sbuf,  int ifd,
 			memcpy(&hdr->magic, rkcommon_get_spl_hdr(params), RK_SPL_HDR_SIZE);
 
 		if (rkcommon_need_rc4_spl(params))
-			rkcommon_rc4_encode_spl(buf, RK_SPL_HDR_START,
-						spl_params.init_size);
+			rkcommon_rc4_encode_spl(buf, header_size,
+						spl_params.images[0].size);
 
-		if (spl_params.boot_file) {
+		if (spl_params.images[1].file) {
 			if (rkcommon_need_rc4_spl(params))
-				rkcommon_rc4_encode_spl(buf + RK_SPL_HDR_START,
-							spl_params.init_size,
-							spl_params.boot_size);
+				rkcommon_rc4_encode_spl(buf + header_size,
+							spl_params.images[0].size,
+							spl_params.images[1].size);
 		}
 	}
 }
@@ -499,6 +546,41 @@ int rkcommon_verify_header(unsigned char *buf, int size,
 	return -ENOENT;
 }
 
+static void rkcommon_print_header_v2(const struct header0_info_v2 *hdr)
+{
+	uint32_t val;
+	int i;
+
+	printf("Rockchip Boot Image (v2)\n");
+
+	for (i = 0; i < ARRAY_SIZE(hdr->boot0_param); i++) {
+		val = le32_to_cpu(hdr->boot0_param[i]);
+		if (val)
+			printf("Boot0 %d: 0x%x\n", i, val);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(hdr->boot1_param); i++) {
+		val = le32_to_cpu(hdr->boot1_param[i]);
+		if (val)
+			printf("Boot1 %d: 0x%x\n", i, val);
+	}
+
+	for (i = 0; i < le16_to_cpu(hdr->num_images); i++) {
+		printf("Image %u: %u @ 0x%x\n",
+		       le32_to_cpu(hdr->images[i].counter),
+		       le16_to_cpu(hdr->images[i].size) * RK_BLK_SIZE,
+		       le16_to_cpu(hdr->images[i].offset) * RK_BLK_SIZE);
+
+		val = le32_to_cpu(hdr->images[i].address);
+		if (val != 0xFFFFFFFF)
+			printf("- Load address: 0x%x\n", val);
+
+		val = le32_to_cpu(hdr->images[i].flag);
+		if (val)
+			printf("- Flag: 0x%x\n", val);
+	}
+}
+
 void rkcommon_print_header(const void *buf, struct image_tool_params *params)
 {
 	struct header0_info header0;
@@ -515,10 +597,7 @@ void rkcommon_print_header(const void *buf, struct image_tool_params *params)
 			return;
 		}
 
-		init_size = header0_v2.images[0].size_and_off >> 16;
-		init_size = init_size * RK_BLK_SIZE;
-		boot_size = header0_v2.images[1].size_and_off >> 16;
-		boot_size = boot_size * RK_BLK_SIZE;
+		rkcommon_print_header_v2(&header0_v2);
 	} else {
 		ret = rkcommon_parse_header(buf, &header0, &spl_info);
 
@@ -532,18 +611,20 @@ void rkcommon_print_header(const void *buf, struct image_tool_params *params)
 		}
 
 		image_type = ret;
-		init_size = header0.init_size * RK_BLK_SIZE;
-		boot_size = header0.init_boot_size * RK_BLK_SIZE - init_size;
+		init_size = le16_to_cpu(header0.init_size) * RK_BLK_SIZE;
+		boot_size = le16_to_cpu(header0.init_boot_size) * RK_BLK_SIZE -
+			    init_size;
 
-		printf("Image Type:   Rockchip %s (%s) boot image\n",
-		       spl_info->spl_hdr,
+		printf("Rockchip %s (%s) Boot Image\n", spl_info->spl_hdr,
 		       (image_type == IH_TYPE_RKSD) ? "SD/MMC" : "SPI");
-	}
 
-	printf("Init Data Size: %d bytes\n", init_size);
+		printf("Init Data: %d @ 0x%x\n", init_size,
+		       le16_to_cpu(header0.init_offset) * RK_BLK_SIZE);
 
-	if (boot_size != RK_MAX_BOOT_SIZE)
-		printf("Boot Data Size: %d bytes\n", boot_size);
+		if (boot_size != RK_MAX_BOOT_SIZE)
+			printf("Boot Data: %d @ 0x%x\n", boot_size, init_size +
+			       le16_to_cpu(header0.init_offset) * RK_BLK_SIZE);
+	}
 }
 
 void rkcommon_rc4_encode_spl(void *buf, unsigned int offset, unsigned int size)
@@ -583,7 +664,7 @@ int rkcommon_vrec_header(struct image_tool_params *params,
 	 * 4 bytes of these images can safely be overwritten using the
 	 * boot magic.
 	 */
-	tparams->header_size = RK_SPL_HDR_START;
+	tparams->header_size = rkcommon_get_header_size(params);
 
 	/* Allocate, clear and install the header */
 	tparams->hdr = malloc(tparams->header_size);
@@ -598,10 +679,12 @@ int rkcommon_vrec_header(struct image_tool_params *params,
 	 * We need to store the original file-size (i.e. before padding), as
 	 * imagetool does not set this during its adjustment of file_size.
 	 */
-	params->orig_file_size = tparams->header_size +
-		spl_params.init_size + spl_params.boot_size;
+	params->orig_file_size = tparams->header_size;
+	for (int i = 0; i < ARRAY_SIZE(spl_params.images); i++)
+		params->orig_file_size += spl_params.images[i].size;
 
-	params->file_size = ROUND(params->orig_file_size, RK_SIZE_ALIGN);
+	params->file_size = rkcommon_get_aligned_size(params,
+						      params->orig_file_size);
 
 	/* Ignoring pad len, since we are using our own copy_image() */
 	return 0;
@@ -685,16 +768,13 @@ err_close:
 
 int rockchip_copy_image(int ifd, struct image_tool_params *params)
 {
-	int ret;
-
-	ret = copy_file(params, ifd, spl_params.init_file,
-			spl_params.init_size);
-	if (ret)
-		return ret;
+	int i, ret;
 
-	if (spl_params.boot_file) {
-		ret = copy_file(params, ifd, spl_params.boot_file,
-				spl_params.boot_size);
+	for (i = 0; i < ARRAY_SIZE(spl_params.images); i++) {
+		if (!spl_params.images[i].size)
+			break;
+		ret = copy_file(params, ifd, spl_params.images[i].file,
+				spl_params.images[i].size);
 		if (ret)
 			return ret;
 	}
-- 
2.47.3

